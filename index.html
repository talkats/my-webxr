<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Floating XR Model Viewer - Fixed</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
        .status {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="xr-button">Start AR</button>
        <input type="file" id="model-upload" accept=".glb,.gltf">
        <div>
            <label for="height">Height: </label>
            <input type="range" id="height" min="0" max="2" step="0.1" value="1.6">
            <span id="height-value">1.6</span>m
        </div>
    </div>
    <div class="status" id="status">Ready</div>
    <canvas id="renderCanvas"></canvas>

    <!-- Load Babylon.js and its modules -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

    <script>
        class FloatingModelViewer {
            constructor() {
                this.canvas = document.getElementById("renderCanvas");
                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                this.currentModel = null;
                this.isModelGrabbed = false;
                this.init();
            }

            async init() {
                // Camera setup
                this.camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1.6, -1));
                this.camera.setTarget(BABYLON.Vector3.Zero());
                this.camera.attachControl(this.canvas, true);

                // Lighting
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), this.scene);

                // XR setup
                try {
                    const xr = await this.scene.createDefaultXRExperienceAsync({
                        uiOptions: { sessionMode: "immersive-ar" }
                    });

                    // Setup model upload
                    this.setupModelUpload();

                    // Create default sphere
                    this.createDefaultModel();

                    // Start render loop
                    this.engine.runRenderLoop(() => {
                        this.scene.render();
                    });

                    window.addEventListener("resize", () => {
                        this.engine.resize();
                    });

                    this.updateStatus("XR initialized successfully");
                } catch (error) {
                    this.updateStatus("XR initialization failed: " + error.message);
                }
            }

            createDefaultModel() {
                const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {
                    diameter: 0.2
                }, this.scene);
                sphere.position = new BABYLON.Vector3(0, 1.6, -0.5);
                this.currentModel = sphere;

                // Add rotation animation
                this.scene.registerBeforeRender(() => {
                    if (this.currentModel && !this.isModelGrabbed) {
                        this.currentModel.rotate(BABYLON.Vector3.Up(), 0.01);
                    }
                });
            }

            setupModelUpload() {
                const fileInput = document.getElementById("model-upload");
                
                fileInput.onchange = async (event) => {
                    if (event.target.files && event.target.files[0]) {
                        const file = event.target.files[0];
                        
                        // Create a FileReader
                        const reader = new FileReader();
                        
                        reader.onload = async (e) => {
                            try {
                                this.updateStatus("Loading model...");
                                
                                // Remove existing model if any
                                if (this.currentModel) {
                                    this.currentModel.dispose();
                                }

                                // Load the model using ArrayBuffer
                                const modelData = e.target.result;
                                const result = await BABYLON.SceneLoader.ImportMeshAsync(
                                    "", 
                                    "data:", 
                                    file.name,
                                    this.scene,
                                    null,
                                    ".glb"
                                );

                                // Get the root mesh
                                this.currentModel = result.meshes[0];
                                
                                // Position the model
                                const height = parseFloat(document.getElementById("height").value);
                                this.currentModel.position = new BABYLON.Vector3(0, height, -0.5);
                                
                                // Scale the model to reasonable size if needed
                                const boundingInfo = this.currentModel.getHierarchyBoundingVectors();
                                const size = boundingInfo.max.subtract(boundingInfo.min);
                                const maxSize = Math.max(size.x, size.y, size.z);
                                if (maxSize > 1) {
                                    const scale = 1 / maxSize;
                                    this.currentModel.scaling = new BABYLON.Vector3(scale, scale, scale);
                                }

                                this.updateStatus("Model loaded successfully");
                            } catch (error) {
                                console.error("Error loading model:", error);
                                this.updateStatus("Error loading model: " + error.message);
                                // Recreate default model if loading fails
                                this.createDefaultModel();
                            }
                        };

                        reader.onerror = (error) => {
                            this.updateStatus("Error reading file: " + error);
                            this.createDefaultModel();
                        };

                        // Read the file as ArrayBuffer
                        reader.readAsArrayBuffer(file);
                    }
                };

                // Height control
                const heightSlider = document.getElementById("height");
                heightSlider.addEventListener("input", (e) => {
                    const height = parseFloat(e.target.value);
                    document.getElementById("height-value").textContent = height.toFixed(1);
                    if (this.currentModel) {
                        this.currentModel.position.y = height;
                    }
                });
            }

            updateStatus(message) {
                const status = document.getElementById("status");
                status.textContent = message;
            }
        }

        // Initialize when page loads
        window.addEventListener("DOMContentLoaded", () => {
            new FloatingModelViewer();
        });
    </script>
</body>
</html>
